Шаг 1: Создание новой таблицы с уникальными именами

- Создать новую таблицу с полями id и name.
- Перенести все уникальные имена из таблицы записей в новую таблицу, устанавливая для каждого имени соответствующий id.

Шаг 2: Изменение структуры таблицы записей
- Добавить новое поле name_id типа integer в таблицу записей.
- Обновить все существующие записи в таблице, установив значение поля name_id для каждой записи, используя соответствующее значение id из таблицы имен.

Шаг 3: Обновление сервисов типа А
- Остановить работу одного из сервисов типа А.
- Изменить код сервиса, чтобы он использовал новую структуру таблицы записей и вместо имени хранил значение поля name_id.
- Запустить обновленный сервис и убедиться, что он работает корректно.
- Повторить шаги 7-9 для всех оставшихся сервисов типа А.

Шаг 4: Обновление сервисов типа Б 
- Остановить работу одного из сервисов типа Б.
- Изменить код сервиса, чтобы он использовал новую структуру таблицы записей и получал имя из таблицы имен, используя соответствующее значение поля name_id.
- Запустить обновленный сервис и убедиться, что он работает корректно.
- Повторить шаги 11-13 для всех оставшихся сервисов типа Б.

Шаг 5: Удалить поле name из таблицы

После выполнения всех шагов старое поле name будет удалено из таблицы записей, и все имена будут храниться в новой таблице с уникальными значениями. Сервисы типа А и Б будут использовать новую структуру таблицы записей и новую таблицу имен, при этом работоспособность системы будет сохранена в процессе миграции.

Важен именно такой порядок обновления сервисов, чтобы сохранить работоспособность системы во время миграции на новую структуру данных.
Если бы сначала были обновлены все сервисы типа Б, то при добавлении новых записей в базу данных сервисы типа А использовали бы старую структуру таблицы записей и, следовательно, вставляли бы данные с именами вместо ссылок на таблицу имен. Это могло бы нарушить целостность данных в базе и привести к ошибкам в работе системы.